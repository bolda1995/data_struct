class RRU_matrix:
    values = []
    columns = []
    pointers = [0]
    n_rows = 0
    m_cols = 0
    def __init__(self, new_values, new_columns, new_pointers, new_n_rows, new_m_cols):
        self.values = new_values
        self.columns = new_columns
        self.pointers = new_pointers
        self.n_rows = new_n_rows
        self.m_cols = new_m_cols

    #транспонирование
    def transposition(self):
        new_values = []
        new_columns = []
        new_pointers = [0]
        counter = 0
        for i in range(len(self.pointers) - 1):
            for j in range(len(self.values)):
                if (self.columns[j] == i):
                    new_values.append(self.values[j])
                    t = 0
                    while (self.pointers[t] <= j):
                        t += 1
                    new_columns.append(t - 1);
                    counter += 1
            new_pointers.append(counter)
        new_rru_matrix = RRU_matrix(new_values, new_columns, new_pointers, self.m_cols, self.n_rows)
        return new_rru_matrix
    
    #суммирование
    def sum(self, other):
        new_values = []
        new_columns = []
        new_pointers = [0]
        
        counter = 0
        for i in range(len(self.pointers) - 1):
            j = self.pointers[i]
            k = other.pointers[j]
            #слияние двух строк
            while (j < self.pointers[i + 1] and k < other.pointers[i + 1]):
                if (self.columns[j] < other.columns[k]):
                    new_values.append(self.values[j])
                    new_columns.append(self.columns[j])
                    j += 1
                elif (self.columns[j] == other.columns[k]):
                    new_values.append(self.values[j] + other.values[k])
                    new_columns.append(self.columns[j])
                    j += 1
                    k += 1
                elif (self.columns[j] > other.columns[k]):
                    new_values.append(other.values[k])
                    new_columns.append(other.columns[k])
                    k += 1
                counter += 1
            while (j < self.pointers[i + 1]):
                new_values.append(self.values[j])
                new_columns.append(self.columns[j])
                j += 1
                counter += 1
            while (k < other.pointers[i + 1]):
                new_values.append(other.values[k])
                new_columns.append(other.columns[k])
                k += 1
                counter += 1
            new_pointers.append(counter)

        new_rru_matrix = RRU_matrix(new_values, new_columns, new_pointers, self.n_rows, self.m_cols)
        return new_rru_matrix
    
    
    #умножение
    def mul(self, other):
        new_values = []
        new_columns = []
        new_pointers = [0]
        new_n_rows = self.n_rows
        new_m_cols = other.m_cols
        #here should be a hell of a lot of checks
        other_t = other.transposition()
        
        counter = 0
        for i in range(len(self.pointers) - 1):
            for j in range(len(other_t.pointers) - 1):
                t_1 = self.pointers[i]
                t_2 = other_t.pointers[j]
                cap_t_1 = self.pointers[i + 1]
                cap_t_2 = other_t.pointers[j + 1]
                summary_elem = 0
                while (t_1 < cap_t_1 and t_2 < cap_t_2):
                    if (self.columns[t_1] < other_t.columns[t_2]):
                        t_1 += 1
                    elif (self.columns[t_1] > other_t.columns[t_2]):
                        t_2 += 1
                    elif (self.columns[t_1] == other_t.columns[t_2]):
                        summary_elem += self.values[t_1]*other_t.values[t_2]
                        t_1 += 1
                        t_2 += 1
                if (summary_elem != 0):
                    new_values.append(summary_elem)
                    new_columns.append(j)
                    counter += 1
            new_pointers.append(counter)
        
        new_rru_matrix = RRU_matrix(new_values, new_columns, new_pointers, new_n_rows, new_m_cols)
        return new_rru_matrix
